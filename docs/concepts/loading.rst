===================
Loading collections
===================

The core of Invoke's execution model involves one or more Collection objects.
While these may be created programmatically, in typical use Invoke will create
them for you from Python modules it finds or is told to use.


.. _collection-discovery:

Task module discovery
=====================

With no other configuration, simply calling ``invoke`` will look for a single
Python module named ``tasks``, and will treat it as the root namespace.
``tasks`` (and any other module name given via :ref:`the load options
<load-options>`) is searched for in the following ways:

* First, if a valid tasks module by that name already exists on Python's
  `sys.path <http://docs.python.org/release/2.6.7/library/sys.html#sys.path>`_,
  no more searching is done -- that module is selected.
* Failing that, search towards the root of the local filesystem, starting with
  the user's current working directory (`os.getcwd
  <http://docs.python.org/release/2.6.7/library/os.html#os.getcwd>`_) and try
  importing again with each directory temporarily added to ``sys.path``.

    * Due to how Python's import machinery works, this approach will always
      favor a package directory (``tasks/`` containing an ``__init__.py``) over
      a module file (``tasks.py``) in the same location.
    * If a candidate is found and successfully imported, its parent directory
      will **stay** on ``sys.path`` during the rest of the Python session --
      this allows task code to make convenient assumptions concerning sibling
      modules' importability.

Candidate modules/packages are introspected to make sure they can actually be
used as valid task collections. Any that fail are discarded, the ``sys.path``
munging done to import them is reverted, and the search continues.


.. _load-options:

Additional load options
=======================

The ``-c`` / ``--collection`` command-line argument allows you to override the
default collection name searched for. It should be a Python module name and not
a file name (so ``-c mytasks``, not ``-c mytasks.py`` or ``-c mytasks/``.) This
option is repeatable and may be used to load multiple collections.

.. note::
    When multiple collections are specified, the first collection given will be
    used as the root or default namespace. The rest will be attached to it as
    sub-collections.

If you need to override the default search start point so Invoke no longer
searches from the current directory, use ``--root``. E.g. if your tasks module
is in ``/opt/code/myproject/tasks.py`` and your CWD is, say, ``/home/myuser``,
you might run Invoke as::

    $ invoke --root /opt/code/myproject


.. _namespaces:

Constructing namespaces
=======================

The base case of loading a single module of tasks works fine initially, but
advanced users typically need more organization, such as separating tasks into
a tree of nested namespaces.

The `~invoke.collection.Collection` class provides an API for organizing tasks
and sub-collections. Collections may include tasks as well as other
collections, and form trees of tasks. When referenced by strings (e.g. on the
CLI or in pre/post hooks) tasks are referenced in a dot syntax, such as
`docs.build`.

In this section, we show how building namespaces with this API is flexible but
also allows following Python package layouts with minimal boilerplate.

Starting out
------------

One unnamed ``Collection`` is always the namespace root; in the implicit base
case, Invoke creates one for you from the tasks in your tasks module.  Create
your own, named ``namespace`` or ``ns``, to set up an explicit namespace::

    from invoke import Collection

    ns = Collection()

Add tasks with `~invoke.collection.Collection.add_task`. ``add_task`` can take
an `~invoke.tasks.Task` object, such as those generated by the
`~invoke.tasks.task` decorator, or can be given a callable object directly.

::
    from invoke import task, run

    @task
    def release():
        run("python setup.py sdist register upload")

    ns.add_task(release)

Our available tasks list now looks like this::

    $ invoke --list
    Available tasks:

        release

Naming your tasks
-----------------

By default, a task's function name is used as its namespace identifier, but you
may override this with the ``name`` argument::

    ns = Collection()
    ns.add_task(release, name='deploy')

.. note::
    The ``name`` kwarg is the 2nd overall argument, so those in a hurry can
    simply say::

        ns.add_task(release, 'deploy')

The result::

    $ invoke --list
    Available tasks:

        deploy

Tasks may have additional names or aliases, given as the ``aliases`` keyword
argument; these are appended to, instead of replacing, any implicit or explicit
``name`` value::

    ns.add_task(release, aliases=('deploy', 'pypi'))

Result, with three names for the same task::

    $ invoke --list
    Available tasks:

        release
        deploy
        pypi

.. note::
    The convenience decorator `@task <~invoke.tasks.task>` is another method of
    setting aliases (e.g. ``@task(aliases=('foo', 'bar'))``, and is useful for
    ensuring a given task always has some aliases set no matter how it's added
    to a namespace.
        
Nesting collections
-------------------

The point of namespacing is to have sub-namespaces; to do this in Invoke,
create additional ``Collection`` instances and add them to their parent
collection via `~invoke.collection.Collection.add_collection`. For example,
let's say we have a couple of documentation tasks::

    @task
    def build_docs():
        run("sphinx-build docs docs/_build")

    @task
    def clean_docs():
        run("rm -rf docs/_build")

We can bundle them up into a new, named collection like so::

    docs = Collection('docs')
    docs.add_task(build_docs, 'build')
    docs.add_task(clean_docs, 'clean')

And then add this new collection under the root namespace with
``add_collection``::

    ns.add_collection(docs)

The result (assuming for now that ``ns`` currently just contains the original
``release`` task)::

    $ invoke --list
    Available tasks:

        release
        docs.build
        docs.clean

As with tasks, collections may be explicitly bound to their parents with a
different name than they were originally given (if any) via a ``name`` kwarg
(also, as with ``add_task``, the 2nd regular arg)::

    ns.add_collection(docs, 'documentation')

Result::

    $ invoke --list
    Available tasks:

        release
        documentation.build
        documentation.clean

* Load already-imported module object, scan for tasks like the automatic
  behavior, add to Collection as X-named sub-Collection
* Load module name string, uses __import__ to obtain module obj, then goes as per above
* Already-existing add_task API for adding tasks to the Collection's own
  namespace
* Make sure collections have names (?)
* Implement actual sub-collection behaviors re: lookup of tasks by name,
  listing etc
* Altering --list display root (can't use --root as that's discovery root; or
  swap?)

Use cases:

* Single-module trivial
* Self-constructed tree matching package layout
* Self-constructed tree with non-package-matching layout
* Assembled from other external trees (may be same as prev)
