Next up:

* Connect Parser/Context with Collection/Task
    * CLI test is just a stub right now, uses empty parser, does nothing with
      collection given
    * Need one Context created per Task, and added to the Parser
        * Perhaps Task.to_context()? (Context should not know about Task
        ideally)
            * Or Collection.contexts()?
        * Needs to go from kwargs to Argument objects
        * And handle name/alias/etc
    * Also need to handle initial Context for e.g. `-c`.
        * Stored in the main cli module?
        * Allow users to override/modify this at some point, this would be how
        they add new core options or whatever
* Make parsing flow suck less. State machine-y?
    * QUESTION: should state transitions cycle back to the current state
    objects' state cells after transitions automatically (and thus
    current-context or current-flag is always referencing the current state),
    or do we keep using current-context and current-flag variables?
    * State changes predicated on "next item in argv":
        * nothing: end
        * flaglike string: flag
        * non-flaglike string: context/task or flag arg
    * Start
        * Set initial context as current-context, move to the 'context' state
    * Context / task name
        * task name: add current-context to results, set current-context to
          this task, or error if not valid
        * flag: set current-flag to this flag
        * end: add current-context to results
    * Flag
        * flag: if current-flag takes value, error. else, set current-flag
        value to True and move on
        * task name: if current-flag takes value, error. else, set current-flag
        value to True and move on
        * end: if current-flag takes value, error. else, set current-flag
        value to True and move on
        * flag arg: if current-flag takes value, ok, keep going. if not, error
    * Flag arg
        * flag: set current-flag value to this value
        * task name: set current-flag value to this value
        * end: you guessed it, set current-flag value to this value
    * Nothing more to parse / end
        * return parse results

Specific things to improve:

* Loader.load_collection should get broken up into multiple smaller
  methods.

API design questions:

* How to handle 1-to-N things like task aliases?
    * Single iterable argument only, eg @task(aliases=('foo', 'bar'))
        * Plus: simple implementation, simple API
        * Minus: requires users to do more work in base case of one alias
    * Singular and plural forms coexisting, e.g. alias='foo' AND
      aliases=('foo', 'bar')
        * Plus: Base case is now handled
        * Minus: complicates implementation, API, adds concerns like "what
          happens if both are given?"

Big questions:

* How to go from subprocess.PIPE to something custom which is capable of
  middleware-type functionality (e.g. logging, mutating etc)?
* How to handle global settings without requiring all functionality to be
  method calls on an object?
    * Require all functionality to be calls on an object, and allow users to
      use an implicit module-global object as the default target?

<!-- vim:set ft=markdown : -->
